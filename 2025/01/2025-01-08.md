# Effective Java

# Item 79. 과도한 동기화는 피하라

- 동기화 영역 안에서의 작업은 최소한으로 작성해야 한다.
    - 동기화는 성능에 직접적인 영향을 미치기 대문에 반드시 필요한 부분에만 작성해야 한다.
- 합당한 이유가 있을 때만 내부에서 동기화하고 동기화했는지 여부를 문서에 명확히 밝혀야 한다.

## 동기화의 문제점

- 멀티스레드 환경에서 동기화는 안전성을 보장하지만 **과도한 동기화**는 다음과 같은 문제가 발생할 수 있다.
    - **성능 저하**
        - 락을 과도하게 사용하면 병렬 처리가 저하되고 경쟁으로 인해 느려짐
    - **교착상태(Deadlock)**
        - 락을 오래 보유하거나 잘못된 설계로 교착상태에 빠질 수 있음.
    - **예측 불가능한 동작**
        - 동기화 영역 내에서 외부 코드나 호출을 허용하면 예외나 데이터 훼손과 같은 문제 발생 가능

## 외계인 메서드

- 동기화 영역 내에서 호출되는, 클래스 외부에서 제공된 메서드
    - 예를 들어 재정의된 메서드, 커스텀 함수 객체 등이 존재한다.
- 외계인 메서드를 호출하면 **제어권을 동기화 블록 밖의 영역으로 넘기게 되어** 예상치 못한 문제가 발생할 수 있다.
    - 아래의 코드에서는 순회하는 동안 대상을 삭제하려고 하기 때문에 **`ConcurrentModificationException`**을 반환한다.

    ```java
    public static void main(String[] args) { 
    		ObservableSet<Integer> set = new ObservableSet<>(new HashSet<>());
    		
    		set.addObserver(new SetObserver<>() {
    				public void added(ObservableSet<Integer> s, Integer e) {
    					System.out.println(e);
    					// 23까지 출력한 다음 ConcurrentModificationException을 던진다
    					if (e == 23) 
    							s.removeObserver(this);
    				} 
    		});
    		for (int i = 0; i < 100; i++) 
    				set.add(i);
    }
    
    // notify ElementAdded 메서드에서 수행하는 순회는 동기화 블록 안에 있으므로 동시 수정이 일어나지 않도록 보장하지만, 정작 자신이 콜백을 거쳐 되돌아와 수정하는 것까지 막지는 못한다.
    private void notifyElementAdded(E element) {
    		synchronized(observers) {
    				for (SetObserver<E> observer : observers) 
    						observer.added(this, element);
    		}
    }
    ```

    - 아래와 같은 코드에서는 교착상태로 인해 정상적으로 실행되지 않는다.

    ```java
    public static void main(String[] args) { 
    		ObservableSet<Integer> set = new ObservableSet<>(new HashSet<>());
    		
    		set.addObserver(new SetObserver<>() {
    				public void added(ObservableSet<Integer> s, Integer e) {
    						System.out.println(e); 
    						if (e == 23) {
    								// 직접 호출하지 않고 별도의 ExecutorService 작성하여 호출
    								ExecutorService exec = Executors.newSingleThreadExecutor(); 
    								try {
    										// 메인 스레드가 이미 락을 쥐고 있기 때문에 백그라운드 스레드가 s.removeObserver를 호출하면 관찰자를 잠그려 시도하지만 락을 얻을 수 없다. 즉, 교착 상태에 빠진다.
    										exec.submit(() -> s.removeObserver(this)).get();
    								} catch (ExecutionException | InterruptedException ex) {
    										throw new AssertionError(ex); 
    								} finally {
    										exec.shutdown(); 
    								}
    						} 
    				}
    		});
    		for (int i = 0; i < 100; i++) 
    				set.add(i);
    }
    
    //
    public boolean removeObserver(SetObserver<E> observer) { 
    		synchronized(observers) {
    				return observers.remove(observer); 
    		}
    }
    ```


### 외계인 메서드 해결 방법

- 외계인 메서드 호출을 동기화 영역 밖으로 옮긴다.
    - **`notifyElementAdded`** 메서드에서는 관찰자 리스트를 복사해 사용하기 때문에 락 없이도 안전하게 순회할 수 있다.

    ```java
    private void notifyElementAdded(E element) { 
    		List<SetObserver<E>> snapshot = null; 
    		synchronized(observers) {
    				snapshot = new ArrayList<>(observers); 
    		}
    		for (SetObserver<E> observer : snapshot) 
    				observer.added(this, element);
    }
    ```

- 위를 좀 더 개선한 방법은 **`CopyOnWriteArrayList`**를 활용하는 것이다.
    - **`CopyOnWriteArrayList`**는 **`ArrayList`**를 구현한 클래스로, 내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행하도록 구현되었다

    ```java
    private final List<SetObserver<E>> observers = new CopyOnWriteArrayList<>();
    
    public void addObserver(SetObserver<E> observer) {
    		observers.add(observer); 
    }
    
    public boolean removeObserver(SetObserver<E> observer) {
    		return observers.remove(observer); 
    }
    
    private void notifyElementAdded(E element) { 
    		for (SetObserver<E> observer : observers)
    				observer.added(this, element); 
    }
    ```


## 동기화 기본 규칙

- **동기화 영역을 최소화한다.**
    - 핵심은 락을 얻고,공유 데이터를 검사하고 필요하면 수정한 뒤,가능한 빨리 락을 해제해야 하는 것이다
    - 즉, 오래 걸리는 작업은 반드시 락 바깥에서 처리해야 한다!
- **동시성이 필요한 상황에서는 동시성 컬렉션을 사용해야 한다.**
    - 동시성 컬렉션들은 내부적으로 고성능 동시성을 제공하므로 개발자가 직접 동기화를 구현하지 않아도 된다.
    - 대표적으로 `ConcurrentHashMap`, `CopyOnWriteArrayList`, `ConcurrentLinkedQueue` 등이 존재한다

### 가변 클래스에서의 동기화 설계

- 가장 단순한 방법은 동기화하지 않는 것이다.
    - 클래스 자체는 스레드 안전성을 제공하지 않고 필요한 경우 사용하는 쪽에서 동기화 책임을 맡게끔 안내하는 것이다.
    - 이 경우에는 반드시 스레드 안전하지 않다는 점을 명시해야 한다
- 두 번째는 **내부 동기화를 적용하는 것이다.**
    - `ConcurrentHashMap`, `CopyOnWriteArrayList` 등의 컬렉션을 통해 클래스가 자체적으로 동기화를 처리하여 스레드 안전을 제공한다.
    - 단, 내부 동기화는 **병렬성을 월등히 개선하는 경우**에만 사용해야 한다.
        - 여기서 병렬성을 월등히 개선한다는 의미는 동기화를 통한 비용보다 **동기화가 제공하는 병렬작업의 장점이 더 큰 경우**를 말한다.
        - 이는 동기화 자체가 성능에 부정적인 영향을 미치기 때문에 다음과 같은 상황에서 권장된다.
            - 읽기 작업이 많고 쓰기 작업이 적을 때 (`CopyOnWriteArrayList`)
            - 세밀한 동기화 제어로 경쟁을 줄일 수 있을 때 (`ConcurrentHashMap`)
            - 락이 짧게 유지되고, 병렬성이 개선되는 경우(`ConcurrentLinkedQueue`)