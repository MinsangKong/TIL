# Effective Java

# Item 86. Serializable을 구현할지는 신중히 결정하라

- `Serializable` 인터페이스를 구현하면 클래스에 직렬화와 관련된 여러 문제들이 발생한다.
    - 이 뿐만 아니라 클래스의 설계와 유지보수에 깊은 영향을 미친다.
- Serializable 구현 여부는 반드시 신중히 검토해야 하며, 가급적 피하는 것을 권장한다.

## Serializable

- Java의 직렬화를 지원하기 위한 마커 인터페이스
    - 직렬화(Serialization) 및 역직렬화(Deserialization) 기능을 제공한다.

    ```java
     public interface Serializable { }
    ```

- Java에서 제공하는 `Serializable`은 객체를 **바이트 스트림으로 변환**해서 파일로 저장하거나, 네트워크로 전송할 수 있도록 도와준다.

### Serializable의 문제점

- 직렬화 형태가 공개 API가 된다
    - 직렬화 가능 클래스를 작성하면 직렬화된 바이트 스트림 형태도 API로 간주된다.
    - 즉, 한번 릴리스된 직렬화된 형태는 지속적으로 지원해야 하기 때문에 클래스 내부 구현 변경이 어렵고 유지보수가 어려워진다.
    - 즉, `Serializable` 구현 시 private 필드까지 공개되어 캡슐화가 깨지고 정보 은닉이 무력화된다.
- 코드 수정 시 호환성 문제가 발생할 수 있다.
    - 클래스 구조 변경이 이루어지면 기존 클래스의 직렬화된 데이터를 새로운 클래스에서 역직렬화할 때 `InvalidClassException`이 발생할 수 있다.
        - 이러한 호환성 문제를 예방하려면 `serialVersionUID`를 명시적으로 정의해야 하지만 유지보수 부담이 증가한다.
- 버그 및 보안 이슈도 발생할 수 있다.
    - 직렬화는 객체 생성 메커니즘의 기본 흐름을 우회하기 때문에 역직렬화 시 객체의 불변식이 깨질 가능성이 높다.
    - 또한 역직렬화 과정에서 공격자가 조작된 스트림을 전달하면 불변식 위반이나 허가되지 않은 접근을 통해 보안 취약점이 발생할 수 있다.
- 테스트 양이 증가한다.
    - 직렬화 가능 클래스는 릴리스할 때마다 호환성을 테스트해야 한다.
    - 직렬화/역직렬화 과정에서 양방향 호환성(신버전 ↔ 구버전)을 보장할 수 있어야 하기 때문에 작업 부담이 크다.
- 익명 클래스, 지역 클래스, 비정적 멤버 클래스는 컴파일러가 자동 생성한 모호한 필드가 포함되기 때문에 직렬화 구조가 불명확해진다.
    - 따라서 이런 클래스에는 `Serializable`을 구현하지 말아야 한다.
- 결론적으로 불필요한 보안 취약점과 테스트 부담을 발생시키고 성능 문제와 구조적 문제까지 초래할 수 있다.

### Serializable가 필요한 상황

- 프레임워크 요구사항인 경우에는 구현해야 한다.
    - 직렬화를 요구하는 프레임워크(예: RMI, JMX 등)를 사용할 경우 또는 다른 클래스가 `Serializable`을 구현한 클래스를 사용해야 한다면구현해야 한다.
- 값(Value) 객체일 때는 이슈가 되지 않는다.
    - 예를 들어 `BigInteger`, `Instant`, `Collections`처럼 데이터를 표현하는 단순 값 객체는 `Serializable`을 구현해도 괜찮다.
    - 하지만 불변식이 중요한 클래스의 경우에는 역직렬화 과정에서 불변식 보장에 유의해야 한다.
- 함수(Function) 객체에는 권장되지 않는다.
    - 예를 들어 스레드 풀 같은 동작 중심의 클래스에는 `Serializable`의 구현을 지양해야 한다.
- 상속 가능한 클래스에는 금지해야 한다.
    - 상속을 위한 설계된 클래스가 `Serializable`을 구현하면 하위 클래스 작성자가 호환성과 직렬화 형태모두 고민해야 한다
- 정적 멤버 클래스는 직렬화해도 괜찮다.
    - 정적 멤버 클래스는 직렬화 구현에 문제가 없기 때문에 특별한 이유가 없다면 직렬화를 허용해도 이슈가 발생하지 않는다.

### **Serializable 구현 시 주의사항**

- serialVersionUID 명시
    - 클래스 내부에 `serialVersionUID`를 명시적으로 선언한다.
    - 자동 생성된 serialVersionUID 값에 의존하면, 필드 추가 등 사소한 변경만으로도 호환성이 깨질 수 있다.

    ```java
     private static final long serialVersionUID = 123456789L;
    ```

- 역직렬화 시 불변식을 보장해야하는 경우 주의가 필요하다.
    - 예를 들어 **readObject()** 메서드의 경우 오버라이드하여 불변식을 반드시 확인해야 한다.

    ```java
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
             ois.defaultReadObject();
             if (필드가 null이거나 불변식에 위배되면) {
                 throw new InvalidObjectException("잘못된 데이터");
             }
         }
    ```

- 드물게 새로운 상위 클래스가 추가되는 경우 기본값으로 초기화된 객체의 불변식을 보장하기 위해 `readObjectNoData()` 메서드를 구현하는 것을 권장한다

    ```java
    private void readObjectNoData() throws ObjectStreamException {
    		throw new InvalidObjectException("데이터가 없습니다.");
    }
    ```

- 직렬화 가능 클래스에서 `finalize()` 메서드를 재정의하면서 반드시 `final`로 선언해야 한다.
    - 이는 finalizer 공격을 방지하기 위함이다.
- 익명 클래스, 지역 클래스, 비정적 멤버 클래스 등의 클래스는 `Serializable` 구현하지 말아야 한다.
    - 추가되는 필드가 모호하고 직렬화 구조가 정해지지 않은 클래스가 `Serializable` 구현`Serializable` 구현하면 심각한 문제가 발생할 수 있다.
    - 그렇지만 정적 멤버 클래스는 `Serializable` 구현해도 문제가 발생하지 않는다.