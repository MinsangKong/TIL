# Effective Java

# Item 82. 스레드 안전성 수준을 문서화하라

- 모든 클래스가 자신의 스레드 안전성 정보를 명확히 문서화해야 한다.
    - 주석으로 명확히 설명하거나 스레드 안전성 애너테이션을 사용할 수 있다
    - 그리고 문서화할 때 클레스의 스레드 안정성 수준이 다를 수 있기에 이 부분을 염두하는 것이 좋다
- 정리하자면 멀티스레드 환경에서 클래스의 스레드 안전성은 중요한 계약 요소이다.
    - 이를 문서화하고 명확하게 전달하지 않으면 클라이언트는 오용할 가능성이 있고, 이는 심각한 오류로 이어질 수 있다.

## 스레드 안전성 문서화

- 스레드 안전성이 높은 수준일수록 명시적 문서화 필요성은 낮다.
    - 문서화를 통해 사용자의 오용을 방지할 수 있고 명확한 문서화는 스레드 안전성을 지키는 첫걸음이 되기 때문에 권장한다
- 반환 타입만으로는 알기 어려운 경우에는 스레드 안전성을 명시해야 한다.
    - 정적 팩터리 메서드에서 반환되는 객체 역시 스레드 안전성도 문서화할 것을 권장한다

### 스레드 안전성 수준

- 불변(Immutable)
    - 객체가 상수처럼 동작하며, 외부 동기화 없이 안전하다.
        - `String`, `Long`, `BigInteger` 등 이 대표적이다.
- 무조건적 스레드 안전(Unconditionally Thread-Safe)
    - 객체 수정 가능하지만, 내부에서 동기화가 철저히 되어 있어 외부 동기화 없이도 안전하다.
        - `AtomicLong`, `ConcurrentHashMap` 등 이 대표적이다.
- 조건부 스레드 안전(Conditionally Thread-Safe)
    - 일부 메서드가 외부 동기화를 요구한다면 동기화가 필요한 조건을 문서화해야 한다.
        - `Collections.synchronizedMap` 등 이 대표적이다.
    - 어떤 순서로 메서드를 호출해야 하고, 어떤 락을 사용해야 하는 지와 같은 동기화 조건을 구체적으로 문서화해야 한다.
- 스레드 안전하지 않음(Not Thread-Safe)
    - 외부에서 모든 접근을 동기화해야 안전하다.
        - `ArrayList`, `HashMap` 등 이 대표적이다.
- 스레드 적대적(Thread-Hostile)
    - 외부에서 아무리 동기화를 해도 멀티스레드 환경에서 동작이 안전하지 않다.
        - 동기화 없이 전역 변수를 갱신하는 코드처럼 정적 데이터에 동기화 없이 접근하거나 동시성을 고려하지 않은 설계를 한 경우에 발생할 수 있다.
- 스레드 안전성에는 여러 수준이 존재하며, 이를 명확히 구분하고 정의해야 한다.

### 락 사용의 공개 여부에 따른 차이

- 외부에서 사용할 수 있는 인스턴스를 락으로 활용하여 클라이언트가 메서드 호출을 원자적으로 처리할 수 있다.
    - 그렇지만 외부에서 락을 사용하면 내부의 고성능 동시성 제어 기능을 활용할 수 없고 클라이언트가 락을 오래 쥐고 놓지 않으면 시스템 성능에 문제를 초래할 수 있다는 단점이 존재한다.
- 외부에서 접근할 수 없는 비공개 락 객체를 사용하면 클라이언트가 클래스의 동기화에 관여할 수 없기 때문에 안전하다
    - 내부 동시성 처리가 간섭받지 않을 뿐더러 Dos 공격도 공격도 방지할 수 있다

### 상속과 락 사용

- 상속용 클래스에서 인스턴스를 락으로 사용한다면 다음과 같은 문제가 발생할 수 있다.
    - 하위 클래스가 상위 클래스의 락을 가져가거나 반대로 사용하면 서로 간섭하기 때문에 데드 락 같은 이슈가 발생할 수 있다.
    - 실제로 `Thread` 클래스를 사용할 때 이런 문제가 자주 발생한다.
- 그렇기 때문에 비공개 락 객체 관용구가 상속 클래스에 적합하다.
    - 상속 구조에서도 상위 클래스와 하위 클래스 간 간섭을 방지할 수 있다!