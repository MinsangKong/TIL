# Effective Java

# Item 89. 인스턴스 수를 통제해야 한다면 readResolve 보다는 열거 타입을 사용하라

- `readResolve` 메서드는 `Serializable` 인터페이스를 구현하는 싱글턴 클래스의 직렬화와 역직렬화 문제를 해결하는 방법이지만 **복잡성과 안전성 문제가 여전히 존재**한다.
    - `readResolve` 메서드를 호출하는 상황에서는 모든 참조 타입 인스턴스 필드를 transient로 선언 해야 문제 발생성이 낮아진다.
- 싱글턴 클래스의 구현 시에는 열거 타입(Enum)을 사용하는 것이 가장 안전하기 때문에 가장 권장되는 방법이다.

## **싱글턴과 직렬화**

- 싱글턴 클래스가 `Serializable`을 구현하면 기본 직렬화 메커니즘 때문에 싱글턴 특성이 깨질 위험이 있다.
    - 역직렬화를 통해 항상 새로운 객체를 생성하기 때문에 결론적으로 기존 인스턴스와 다른 객체를 생성하게 된다.
- `readResolve` 메서드를 사용하면 역직렬화된 객체를 싱글턴 인스턴스로 대체할 수 있다.

### **transient**

- 필드를 Java의 객체 직렬화에서 제외하는 키워드 키워드

    ```java
    public class Elvis implements Serializable {
    		public static final Elvis INSTANCE = new Elvis();
        private Elvis() { }
        private String[] favoriteSongs = { "Hound Dog", "Heartbreak Hotel" };
    
    		// 기존 싱글턴 인스턴스를 반환하고, 역직렬화된 객체는 무시한다. 즉, 새로 역직렬화된 객체는 가비지 컬렉터에 의해 수집된다
        private Object readResolve() {
               return INSTANCE;
        }
    }
    ```

- `readResolve`를 사용하는 클래스의 모든 **가변 참조 필드를 `transient`로 선언**해야 한다.
    - 직렬화 시 클래스의 비휘발성(non-transient) 필드가 직렬화된 데이터에 포함되기 때문이다.
    - 이를 악의적인 스트림으로 조작하면 데이터가 오염될 수 있다.
    - `transient`를 사용하면 역직렬화 시 해당 필드는 NULL로 초기화된다.
- 싱글턴의 필드가 `transient`로 선언되지 않았다면 악의적인 공격자가 직렬화 스트림을 조작해 **역직렬화된 객체를 탈취**할 수 있다.
    - 예를 들어 `Stealer(도둑)` 클래스는 `readResolve` 호출 전에 객체에 접근해 정보를 탈취하거나 **싱글턴의 불변성을 파괴**할 수 있다.
- 결론적으로 안전한 코드를 위해 모든 가변 객체 필드는 반드시 **`transient`로 선언**해야 한다.

### 열거 타입 싱글턴

- 싱글턴을 구현하는 가장 안전하고 간단한 방법은 **열거(Enum) 타입**을 사용하는 것이다.

    ```java
    public enum Elvis {
    		INSTANCE;
        private String[] favoriteSongs = { "Hound Dog", "Heartbreak Hotel" };
    
        public void printFavorites() {
    		    System.out.println(Arrays.toString(favoriteSongs));
        }
    }
    ```

- 열거 타입은 직렬화와 역직렬화를 자동으로 처리하기 때문에 자바가 **단일 인스턴스 보장**을 제공한다.
- 코드가 간결하고 유지보수가 용이하다.
    - 직렬화가 기본적으로 안전하므로 `readResolve` 같은 메서드를 구현할 필요가 없기 때문이다.
- 상황에 따라 리플렉션을 통해 인스턴스 생성을 방지할 수 있다.