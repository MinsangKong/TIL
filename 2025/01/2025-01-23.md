# Effective Java

# Item 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라

- 제3자가 확장할 수 없는 클래스라면 직렬화 프록시 패턴(Serialization Proxy Pattern)을 사용하는 것을 권장한다.
    - 직렬화(Serialization)를 지원하는 클래스는 생성자 이외의 경로를 통해 인스턴스가 생성되기 때문에 **버그와 보안 문제의 위험이 증가할 수 있기 때문에 이를 염두해야 한다.**
- 직렬화 프록시 패턴을 통해 중요한 불변식을 안정적으로 직렬화할 수 있다.

## 직렬화 프록시 패턴

- 직렬화와 역직렬화 ****과정에서 데이터의 무결성을 보장하기 위한 디자인 패턴
    - 바깥 클래스의 내부 상태를 정확하게 표현하기 위해 **바깥 클래스의 논리적 상태를 담은 중첩(static) 클래스**를 사용한다.
    - 이를 바탕으로 **직렬화 시 프록시 객체를 사용하고** 역직렬화 시 해당 프록시에서 원래 객체로 복원한다.
- 대략적인 작성 방식은 다음과 같다
    - **바깥 클래스**
        - `writeReplace` 메서드를 통해 직렬화 프록시를 반환하도록 구현한다.
        - 또한 `readObject` 메서드를 Override하여 직접 직렬화되지 못하도록 방지한다.
    - **프록시 클래스**
        - 바깥 클래스의 데이터를 복사하고 `readResolve` 메서드를 사용하여 역직렬화 시 바깥 클래스 객체로 복원한다.

### 직렬화 프록시 예시

- 바깥 클래스의 내부 상태를 그대로 저장할 필드를 가진 **`private static` 중첩 클래스**를 정의하고 바깥 클래스의 데이터를 완전히 복사하여 생성한다.

    ```java
    // Serializable 구현하고 serialVersionUID를 반드시 지정해야 한다.
    private static class SerializationProxy implements Serializable {
    		private final Date start;
        private final Date end;
    
           SerializationProxy(Period p) {
               this.start = p.start;
               this.end = p.end;
           }
    
           private Object readResolve() {
               // 바깥 클래스의 public 생성자를 사용해 원래 객체로 복원
               return new Period(start, end);
           }
    
           private static final long serialVersionUID = 234098243823485285L;
       }
    ```

- 바깥 클래스에 `writeReplace` 구현한다.
    - `writeReplace` 메서드는 직렬화 시 바깥 클래스 인스턴스 대신 프록시 객체를 반환하도록 한다.
    - 직렬화를 수행 시, 바깥 클래스 자체가 직렬화되지 않고 직렬화 프록시(`SerializationProxy`)가 사용된다.

    ```java
    private Object writeReplace() {
    		return new SerializationProxy(this); // 프록시 객체 반환
    }
    ```

- 바깥 클래스에 속한 `readObject` 메서드는 기본 직렬화 메커니즘이 바깥 클래스를 직접 역직렬화하지 못하도록 한다.

    ```java
    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
    		throw new InvalidObjectException("프록시가 필요합니다.");
    }
    ```

- 직렬화 프록시 클래스에 `readResolve` 메서드를 구현하여, 역직렬화된 프록시 객체를 **바깥 클래스의 인스턴스**로 변환한다.
    - `readResolve` 메서드는 반드시 바깥 클래스의 API(public 생성자, 정적 팩터리 등)를 사용해야 한다.

    ```java
    private Object readResolve() {
    		return new Period(start, end); // Bar깥 클래스 생성자로 변환
    }
    ```


### 직렬화 프록시 패턴 장점

- 불변식(Integrity) 보장한다.
    - `readResolve`에서 바깥 클래스의 API(Some Constructor, 팩터리 메서드)를 이용해 객체를 생성하므로 불변성이 자동으로 보장된다.
    - 즉, 다른 방법 없이 기존 생성자 로직으로 상태를 재구성하기 때문에 추가적인 유효성 검증이 필요 없다.
- 가짜 직렬화 스트림 공격이나 내부 필드 탈취 공격을 방지하여 보안이 강화된다.
    - 직렬화된 객체는 프록시를 거쳐야만 하므로, 수작업으로 작성된 잘못된 객체를 생성할 수 없다.
    - 즉, 가변 객체를 안전하게 다룰 수 있다.
- 진정한 의미에서 불변 클래스 구현할 수 있다.
    - 직렬화 프록시 패턴 사용 시 바깥 클래스의 필드를 `final`로 선언 가능하기 때문에 불변 클래스를 완전한 의미로 구현할 수 있다.
- 유연성이 확장된다.
    - 직렬화 프록시는 생성될 클래스가 원래 직렬화된 클래스와 달라도 문제가 없다.
    - 예를 들어 `EnumSet` 클래스는 사용되는 열거형 값의 크기에 따라 다른 내부 클래스를 결정하지만 이런 다양한 클래스도 직렬화 프록시를 활용해 안전하게 정상 동작한다.

### **직렬화 프록시 패턴의 한계**

- 클라이언트 확장이 불가능한 클래스에만 적용 가능하다.
    - 클라이언트 코드가 상속해서 사용할 수 있는 클래스는 직렬화 프록시 사용에 적합하지 않다.
    - 이는 프록시 클래스 설계 시 논리적으로 올바른 상속 계층을 파악하기 어렵기 때문이다.
- 객체 그래프의 순환(Cyclic Relationship) 지원이 불가능하다.
    - 객체 사이의 순환 참조가 있는 경우에 직렬화 프록시에서 순환 참조된 객체를 역직렬화 시 `ClassCastException`이 발생한다.
    - 이는 역직렬화 중 프록시 객체로 연결이 성립되지 않기 때문이다.
- 일반적인 직렬화보다 약간의 오버헤드가 생길 수 있다.
    - 예를 들어 동일한 로직에서 방어적 복사를 사용하는 방법보다 10~20% 느릴 수 있다.

### **EnumSet의 직렬화 프록시**

- **`EnumSet` 클래스**는 크기에 따라 **`RegularEnumSet`** 또는 **`JumboEnumSet`** 클래스를 반환한다.

    ```java
    private static class SerializationProxy<E extends Enum<E>> implements Serializable {
        private final Class<E> elementType;    // EnumSet의 열거 타입
        private final Enum<?>[] elements;     // EnumSet의 원소
    
        SerializationProxy(EnumSet<E> set) {
            elementType = set.elementType;
            elements = set.toArray(new Enum<?>[0]);
        }
    
        private Object readResolve() {
            EnumSet<E> result = EnumSet.noneOf(elementType);
            for (Enum<?> e : elements) {
                result.add((E) e);
            }
            return result;
        }
    
        private static final long serialVersionUID = 362491234563181265L;
    }
    ```

- 열거 원소의 크기가 달라질 경우, 직렬화된 프록시가 다른 내부 클래스로 변환된다.
- EnumSet은 직렬화 프록시 패턴을 통해 원활히 이 작업을 지원한다.