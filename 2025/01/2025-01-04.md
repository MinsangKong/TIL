# Effective Java

# Item 76. 가능한 한 실패 원자적으로 만들라

- 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지되어야 한다
    - 이 규칙을 지키지 못한다면 실패 시의 객체 상태를 API 설명에 명시하여 호출자에게

## **객체를 원자적으로 만드는 방법**

- 객체가 원자적인 경우에는 메서드 호출이 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지한다
    - 즉, 예외 발생 시에도 객체 상태가 일관성을 유지하므로 신뢰성과 복원 가능성을 높다!
- 특히 검사 예외의 경우 호출자가 오류를 복구할 수 있도록 하는 데 유용하다
- 실패 원자성은 일반적인 상황에서는 지켜야하지만 상황에 따라 제약이 존재할 수 있다.
    - 동기화 이슈나 복구가 불가능한 예외가 발생한 상황에서는 불가능할 수 있다
    - 이 경우에는 API 문서에 상태 변화에 대한 설명을 반드시 명시해야 함.

### **불변 객체(Immutable Object) 사용**

- 불변 객체는 실패 원자적인 특성을 태생적으로 갖고 있다.
    - 즉, 실패 시 새로운 객체를 만들어내지 않을 수 있지만 기존 객체에 영향을 주지 않는다!
- 결론적으로 불변 객체는 생성 시 상태가 고정되기 때문에 예외의 영향으로 상태가 변경되지 않는다

### **매개변수 유효성 검증**

- 메서드 호출 전에 매개변수의 유효성을 미리 검사하여 오류 가능성을 줄일 수 있다.
    - `Stack` 클래스의 pop() 메서드의 경우 크기가 0인지 먼저 확인하여 배열 인덱스가 꼬이는 케이스를 방지했다

    ```java
    public Object pop() {
    	if (size == 0)
    		throw new EmptyStackException();
    	Object result = elements[--size]; 
    	elements[size] = null; // 다 쓴 참조 해제 
    	return result;
    }
    ```


### 객체 상태 변경 이전에 실패 가능 코드 배치

- 예외가 발생할 가능성이 있는 코드를 객체 내부 상태를 변경하기 전에 실행한다
    - `TreeMap`은 원소를 추가하기 전에 **타입 비교**를 수행하여 `ClassCastException`이 발생하면 TreeMap의 상태가 변경되지 않는다.

### **임시 객체에서 작업 수행 후 교체**

- 객체의 임시 복사본을 만들어 작업하고 작업이 완료되면 원래 객체와 바꾸는 방식이다
    - 예를 들어 정렬 알고리즘에서 정렬하기 전에 입력 리스트의 원소를 배열에 복사하고 정렬을 수행한다.
- 작업이 실패하더라도 원래 리스트는 변경되지 않은 상태로 유지되기 때문에 안전하다

### **작업 실패 시 복구 코드 사용**

- 작업 중 예외가 발생하면 객체를 **작업 이전 상태로 복구**하는 코드를 작성한다
- 주로 **내구성을 보장할 필요가 있는 디스크 기반 자료구조** 등에서 사용하고 일반적으로 자주 사용하는 방식은 아니다