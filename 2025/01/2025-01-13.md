# Effective Java

# Item 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라

- 프로그램의 동작을 스레드 스케줄러에 의존해서는 안된다.
    - 스레드 스케줄러는 실행 중인 스레드들을 적절히 스케줄링하지만 그 정책은 운영체제마다 다를 수 있다.
    - 즉, 잘 작성된 프로그램은 스레드 스케줄링 정책에 의존하지 않아야 하며, 플랫폼이나 환경에 구애받지 않고 일관되게 동작해야 한다.
- 동일한 이유로 **`Thread.yield`**와 스레드 우선순위에 의존하지 않아야 한다.

## 스레드 스케줄러 권장 사항

- 실행 가능한 스레드 수를 제한해야 한다.
    - 실행 가능한 스레드의 수를 프로세서 수를 초과하지 않도록 유지하는 것이 최적이다.
    - 실행 가능한 스레드가 적으면 스케줄러의 부담이 줄고 스레드가 할당받은 CPU 시간을 최대한 활용할 수 있다.
- 작업이 없으면 스레드는 대기 상태로 만들어야 한다.
    - 스레드는 작업이 있을 때만 실행되어야 하며, 작업이 없는 경우 대기 상태로 돌아가야 한다.
    - 즉, 스레드가 무작정 실행되고 있으면 성능이 저하되고 이식성이 떨어진다.
- 바쁜 대기(busy waiting)를 피해야 한다.
    - CPU를 낭비하고 다른 유용한 작업의 실행 기회를 빼앗길 수 있다.
    - 실행 대기 상태에서는 `CountDownLatch`, `Semaphore`와 같은 ****동기화 도구를 활용하는 것이 낫다.
    - 실행 준비가 된 스레드의 수를 제한하고 다음 작업이 준비될 때까지 스레드는 대기 상태에 두는 방식으로 프로세스를 설계하는 것의 옳다

    ```java
    // 바쁜 대기를 통해 count 상태를 계속 확인한다.
    while (true) {
        if (count == 0) {
            break;
        }
    }
    ```

- **`Thread.yield`**를 사용하지 말아야 한다.
    - **`Thread.yield()`**는 초점이 잘못된 문제 해결 방식으로 운영체제 및 JVM에 따라 동작이 달라진다.
    - 오히려 애플리케이션의 구조를 조정해 동시에 실행 가능한 스레드 수를 줄이는 방식으로 접근하는 것이 낫다.
- 스레드 우선순위를 변경하지 말아야 한다.
    - 스레드 우선순위 설정은 이식성이 낮으므로 가능한 피해야 한다.
    - 우선순위를 통해 성능을 개선하려는 노력은 같은 문제가 반복될 수 있으며 근본적인 해결책이 아니다.