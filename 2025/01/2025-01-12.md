# Effective Java

# Item 83. 지연 초기화는 신중히 사용하라

- 반드시 필요한 상황이 아니라면 지연 초기화는 사용을 지양해야 한다.
- 정적 필드에는 `Lazy Initialization Holder Class`, 인스턴스 필드에는 `Double-Checked Locking`을 고려하는 것이 좋다.

## 지연 초기화(Lazy Initialization)

- 필드의 초기화 시점을 해당 값이 처음 접근될 때까지 늦추는 최적화 기법
    - 초기화를 미룬다는 점에서 성능에 도움이 될 가능성도 있지만, 잘못 사용할 경우 성능 및 코드 복잡도 면에서 비용이 더 클 수 있다
- 일반적으로 지연 초기화가 필요하면 **`synchronized`** 키워드를 사용해서 지연 초기화를 진행한다
    - 클래스 또는 객체 초기화의 순환 문제 해결을 위해 사용할 수도 있다

    ```java
    private FieldType field;
    
    synchronized FieldType getField() {
        if (field == null) {
    		    // 지연 초기화
            field = computeFieldValue();
        }
        return field;
    }
    ```


### 지연 초기화 장점

- 초기화 비용이 절감된다.
    - 필드가 사용되지 않으면 초기화도 일어나지 않기 때문에 클래스 초기화 비용을 줄일 수 있다.
- 클래스와 인스턴스 초기화 시 발생할 수 있는 순환 의존성 문제를 피할 수 있다.

### 지연 초기화 단점

- 성능 저하 가능성이 존재한다.
    - 지연 초기화를 적용하면 필드 접근 시 오히려 비용이 증가할 수 있고 초기화 시점 연기로 인해 성능에 악영향을 줄 가능성도 있다.
- 코드 복잡도가 증가한다.
    - 특히 멀티스레드 환경에서 지연 초기화는 동기화 문제를 해결해야 하기 위한 코드가 추가되기 때문에 복잡도가 증가한다.
- 추가적으로 최적화 판단이 어렵다
    - 필드 초기화가 필요하지 않은 경우가 많지 않고 적용 전후 성능 평가 없이는 효과를 단정하기 어렵다.

### 지연 초기화가 적합한 상황

- 필드 초기화 비용이 높지만 사용 빈도가 낮을 경우 적합하다
- 특정 환경 또는 특정 인스턴스에서만 필요한 경우 적합하다

### **Lazy Initialization Holder Class**

- 정적 필드의 지연 초기화를 안전하고 간단하게 구현하기 위한 디자인 패턴
    - **Java 클래스 로딩의 특징**을 활용하여 **필드에 동기화 비용을 추가하지 않으면서도 thread-safe**하게 지연 초기화를 제공한다

    ```java
    private static class FieldHolder {
    		// 외부에서 getField 메서드를 호출해 field에 접근하는 순간 FieldHolder 클래스가 로드되고 정적 필드가 초기화
        static final FieldType field = computeFieldValue();
    }
    
    static FieldType getField() {
        return FieldHolder.field;
    }
    ```

- 내부 정적 클래스에 정적 필드를 선언하면 해당 필드는 외부 클래스에서 필요하기 전까지 초기화되지 않으며, 필요할 때 초기화가 **thread-safe**하게 이루어진다.

### **Double-Checked Locking**

- 멀티스레드 환경에서 성능과 **thread-safe 초기화**를 모두 보장하기 위한 디자인 패턴
    - 인스턴스 필드 초기화 비용을 줄이기 위해 고안된 기법이다.

    ```java
    private volatile FieldType field;
    
    FieldType getField() {
    		// 첫 번째 (비동기화) 검사
        FieldType result = field; 
        // 필드 미초기화 시
        if (result == null) { 
            synchronized (this) {
    		        // 두 번째 (동기화된) 검사
                result = field; 
                if (result == null) { 
    		            // 필드가 여전히 미초기화 상태라면 초기화 진행
                    field = result = computeFieldValue(); 
                }
            }
        }
        return result; 
    }
    ```

- 메모리 접근 비용이나 동기화 비용이 민감한 경우 효율적이다.
- **`instance`** 필드는 반드시 **`volatile`**로 선언되어야 한다.
    - **`volatile`** 없이는 초기화 완료 전에 참조가 발생하는 심각한 문제가 발생할 수 있다.
    - 초기화가 완료되기 전에 다른 스레드에서 `instance`를 참조하려는 문제를 방지할 수 있다.
- 초기화가 반복적으로 발생해도 괜찮고 초기화 비용이 크지 않을 경우에는 **`Single-Checked Locking`**을 활용할 수 있다

    ```java
    private volatile FieldType field;
    
    FieldType getField() {
        if (field == null) {
    		    // 초기에 접근한 스레드가 초기화
            field = computeFieldValue(); 
        }
        return field;
    }
    ```