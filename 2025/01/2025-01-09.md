# Effective Java

# Item 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라

- 스레드를 직접 생성하는 것을 지양해야 한다.
    - 스레드를 직접 생성하면 스레드가 작업 단위와 실행 메커니즘 역할을 모두 수행해야 하기 때문이다.
- 실행자 프레임워크가 작업 수행의 표준화된 메커니즘을 제공하기 때문에 이점이 많다.
    - 그로 인해 얻을 수 있는 이점은 다음과 같이 정리할 수 있다.
        - **안전성과 편의성**
        - **유연하고 재사용 가능한 설계**
        - **병렬성과 성능 극대화**

## ExecutorService

- java.util.concurrent 패키지에서 제공하는 인터페이스로, **`Executor`**의 하위 인터페이스.
    - **`Runnable`**이나 **`Callable`** 작업을 비동기적으로 실행하고, 작업의 결과를 **`Future`**라는 객체로 받을 수 있는 기능 등을 제공한다.
    - 즉, **`Executor`**를 상속받아 작업 등록 뿐만 아니라 실행도 진행할 수 있다.
- 복잡한 동시 작업 관리를 간단히 처리할 수 있다
    - `Future` 객체의 `get()` 메서드를 사용하여 특정 태스크의 완료 대기할 수 있다
    - `invokeAny()`/`invokeAll()` 를 활용하여 태스크들의 결과를 효율적으로 처리할 수 있다
    - `awaitTermination()`를 활용하여 스레드 풀 종료 대기할 수 있다
    - 상황에 따라 필요한 구현체를 설정할 수 있다.
        - 완료된 태스크 순서에 따라 결과 처리가 필요한 경우에는 `ExecutorCompletionService`
        - 지정된 시간/주기로 작업 실행이 필요한 경우에는 `ScheduledThreadPoolExecutor`
- 기존 단순 작업 큐보다 선택지가 다양하다.
    - 단일 쓰레드 실행자가 필요한 상황이면 `newSingleThreadExecutor()`
    - 고정된 스레드 풀이 필요한 상황이면 `newFixedThreadPool(n)`
    - 캐시된 스레드 풀이 필요한 상황이면 `newCachedThreadPool()`