# Effective Java

# Item 27. 비검사 경고를 제거하라

- 비검사 경고는 중요하니 무시해서는 안된다.
    - **@SuppressWarnings("unchecked")** 애너테이션을 사용할 때면 그 경고를 무시
      해도 안전한 이유를 항상 주석으로 남겨야 한다
- @SuppressWarnings은 가능한 한 좁은 범위에 적용하자.

## @SuppressWarnings

- 컴파일러 경고를 무시하도록 지시하는 데 사용하는 어노테이션
    - 일반적으로 이전 버전의 Java 코드를 유지 관리하거나 특정 경고를 일반적으로 무시하는 용도로 사용한다.

    ```java
    @SuppressWarnings("unchecked")
    public void run() {
        List myList = new ArrayList();
        myList.add("test");
        List<String> anotherList = myList;
    }
    ```

- 모든 비검사 경고는 잠재적으로 애플리케이션에 가장 위험한 런타임에러(ClassCastException)를 띄울 수 있으므로 특별한 이유가 없다면 제거해야 한다.

# Item 28. 배열보다는 리스트를 사용하라

- 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
    - 그렇기에 제네릭과 호환이 잘되는 리스트를 권장한다.

## Array

- 동일한 타입의 여러 값을 저장하는 저장공간
    - 배열의 길이는 생성 시에 정의되며 이후부터는 변경할 수 없다.
- 배열은 **공변**이 적용된다.
    - 공변성은 서브타입 관계를 가지는 원래 타입 간에 배열의 타입 관계를 유지한다는 타입 변환 원칙을 의미한다.
    - 그렇기에 서브 타입으로 타입 캐스팅이 가능하다!
- 배열은 실체화된다.
    - 실체화(Reified)된다는 것은 배열이 자신들의 런타임 타입을 항상 알고 있다는 의미이다.

```java
Integer[] intArray = new Integer[3];

// 배열에는 공변성이 적용
Object[] objArray = intArray; 

// 타입에 맞지 않는 값이기에 런타임에 ArrayStoreException이 발생한다
objArray[0] = "Hello"; 
```

## List

- 순서가 있는 컬렉션을 다루는 인터페이스
    - 개별 요소를 인덱스에 의해 접근할 수 있으며, 동일한 요소가 여러 번 포함될 수 있다.
- 리스트는 런타임에 제네릭 타입의 구체적인 타입 정보를 알 수 없다.
    - 제네릭은 실행시에는 타입 정보가 완전히 제거되는 타입 소거(type erasure) 방식을 사용이 된다.
    - 즉, 제네릭은 **실체화 되지 않는다**는 의미이다
- 리스트는 불공변하다.
    - 리스트는 상위타입으로 하위 타입을 받을 수 없다는 의미이다.
    - 그렇지만 와일드카드를 사용하여 제네릭 유형의 공변성을 허용하게 할 수 있다!

```java
List<Dog> dogs = new ArrayList<>();

// 공변성이 적용되지 않기에 컴파일 에러 발생
List<Animal> animals = dogs; 

// 한정적 와일드 카드를 사용하면 어느 정도 공변성을 얻을 수 있음
List<? extends Animal> someAnimals = dogs; 
```

## Array vs List(Generic)

- 배열은 공변이고 실체화되지만, 리스트는 불공변이고 런타임에 타입 정보가 소거된다.
    - 배열은 런 타임에 에러 가능성이 존재하고, 제네릭은 컴파일 타임에 에러를 감지할 수 잇다.
    - 일반적으로 에러는 컴파일 타임에 잡는 것이 안정적이기에 배열보다는 리스트가 더 안정적이다.
- 배열과 제네릭은 서로 호환되지 않다.
    - 그렇기에 배열과 함께 사용되는 제네릭이 있고, 컴파일 타임에 오류가 자주 발생한다면 반드시 배열이 필요한지 고민해보고 최대한 리스트로 바꾸는 것이 안전하다.

### ArrayList

- Java의 List 인터페이스를 구현한 클래스
    - 내부적으로 배열을 사용하여 요소를 저장하지만 배열과는 달리 ArrayList의 크기는 동적으로 바뀔 수 있다.
    - 즉, 요소를 추가하거나 제거할 때 ArrayList는 자동으로 메모리를 재조정한다
- 근본적으로 List이기에 불공변적이고 실체화되지 않는다는 특징을 갖고 잇다.
    - **내부적으로 배열을 사용하지만, 제네릭과 호환이 잘되기에 가능하면 배열보다는 ArrayList를 사용하는 것이 좋다!**
- 내부적으로 배열을 사용하기에 ArrayList로 명명되었다
    - LinkedList는 내부적으로 연결 리스트를 사용하고, HashMap은 해시 테이블을 사용한다