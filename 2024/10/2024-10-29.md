# Effective Java

# 인스턴스화를 막으려거든 private 생성자를 사용하라

- 추상클래스로 만드는 것만으로는 인스턴스화를 막을 수 없다
    - 하위 클래스를 만들어 인스턴스화하면 가능하기 때문에!
- private 생성자를 추가하면 인스턴스화를 막을 수 있다.

```java
public class UtilityClass {
 
	// 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
	private UtilityClass() {
		throw new AssertionError(); 
	}
	...
}
```

## Utility Class

- 재사용성과 범용성을 고려하여 정적 필드와 정적 메서드로 이루어진 클래스
- 레강트 오브젝트같이 객체지향에 깊이 다룬 책에서는 유틸 클래스 대신 도메인 내 정적 메서드를 사용하는 것을 권장한다.
    - 그렇지만 별도의 Utils 패키지를 만들고, 해당 패키지 내에서 처리하면 괜찮다고 생각한다.
    - 작성하더라도 private 생성자를 통해 인스턴스 생성 방지해야 한다. 상태를 가지면 안된다!
    - 자바 8부터는 인터페이스의 디폴트 메서드를 활용해 더 나은 클래스로 만들 수 있다.
        - 그렇지만 팀 코드 컨벤션에 맞춰서 인터페이스/Utility Class로 작성하는 것이 중요하다
        - 하지만 인터페이스를 작성하면 확실하게 인스턴스화를 막을 수 있다
- 참조
    - https://stackoverflow.com/questions/3340032/utility-classes-are-evil

# 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.
    - 즉, @Component와 @RequiredArgsConstructor를 통해 필요한 빈을 주입받고, 해당 유틸 클래스를 필요한 곳에서도 주입받아 사용해야 한다.

## **Singleton/Utility Class의 문제점**

- **Singleton/Utility Class**는 상태를 가지면 멀티스레딩 환경에서 버그를 불러일으킬 수 있다.
    - 상태를 가지지 않는 Singleton/Utility Class는 thread-safe하다!
- 싱글턴은 상황에 따라 테스트 하기가 어렵다.
    - 싱글턴 인스턴스의 생성을 제어하기에 제약이 존재
    - 그로 인해 테스트를 위해 객체를 조작하거나 mock 정보를 넣는 행위에 제약이 발생!
