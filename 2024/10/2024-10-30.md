# Effective Java

# **불필요한 객체 생성을 피해라**

사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다. 대신 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식이다.(DI)

의존성 주입을 통해 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.

```java
public class Dog {
    private static final String CONSTANT_HI = "Static 선언된 객체는 무조건 재사용 가능";
    String newHi = new String("매번 새로운 string을 생성");
    String reuseHi = "단순 문자열의 경우도 재사용을 보장!";
}
```

## 생성이 불필요한 객체

- 불변 객체나 상태가 변하지 않을 것임이 분명한 가변 객체
- 생성 비용이 커서 캐싱의 이점을 누릴 수 있는 객체
- 어댑터 패턴을 사용하는 객체

## 하지만 생성을 두려워 하지 마라

요즘의 JVM과 GC는 성능이 뛰어나기 때문에 작은 객체를 생성하고 회수하는 비용은 매우 작다. 무의미한 객체 생성을 주의해야한다는 의미이다.

**불필요한 객체 생성을 하지말라**는 말의 요지는 **불필요한** 이지, **생성을 하지말라**가 아니다!

## **의도치 않은 오토박싱**

- Long 타입과 long 타입간의 오토박싱이 매우 많이 일어날 것이다.
    - sum을 Long으로 선언했다는 하나의 실수로 인해 엄청난 성능 저하를 겪을 수 있다!
    - 심지어 오류가 발생을 해도 바로 인지하기가 어렵다

```java
private static long sum() {
		Long sum = 0L;
		for (long i = 0; i <= Integer.MAX_VALUE; i++)
			sum += i;

		return sum;
} 
```

# 다 쓴 객체 참조를 해제하라

- 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다.
- 코드 리뷰나 Heap Dump 분석같은 디버깅 도구를 동원해야만 발견 가능하다. 그래서 예방법을 익히는 것이 중요하다.

## Garbage Collector

- 자바는 가비지 컬렉터(Garbage Collector, GC)를 활용한다.
    - GC는 참조하지 않는 객체(unreachble object)들을 수거해간다.
    - 이 참조가 해제되지 않으면 GC가 해당 메모리를 수거대상이라고 인식하지 못한다.
    - 이렇게 사용하지 않는 객체가 쌓이고 쌓이다보면 로직에선 사용되지 않는 메모리로 인해 프로그램 성능이 영향을 받게 되는데, 이를 ***메모리 누수*** 라고 한다.
- Java의 가비지 컬렉션(GC)는 힙 메모리 영역을 관리한다.
    - 힙 메모리는 크게 Young 영역과 Old 영역으로 구분된다.
    - Young 영역은 Eden 영역과 두 개의 Survivor 영역으로 나뉘어 진다.
        - Eden 영역이 가득 차게되면 Minor GC가 발생하고, Eden 영역에서 살아남은 객체들은 Survivor 영역으로 이동한다.
        - 하나의 Survivor 영역이 가득 차게되면 생존한 객체들은 통상적으로 Old 영역으로 이동되거나, 아니면 다른 Survivor 영역으로 이동한다.

## 예방

- 일반적인 경우, null을 직접적으로 넣어 처리하기보다 gc를 통해 처리하는게 깔끔하다.
- 자기 메모리를 직접 관리하는 클래스라면, 메모리 누수에 주의해야한다.
    - ex) Stack, Array, Custom 자료 구조 등등
- 자체 구현한 자료구조 혹은 객체 배열을 활용하는 경우, 로직 상 더 이상 사용하지 않는 영역인데 참조는 해제되지 않는 경우가 있다.
    - 이 경우에는 null할당을 통해 해결할 수 있다.
    - 그렇지만 null은 NPE를 일으키는 주범이기에  '**메모리 누수를 막기 위해'** 같은 명확한 이유가 있는 경우만 사용해야 한다!